// File generated by dotnet-combine at 2024-03-25__20_45_41

using ORL.Layout.Elements;
using ORL.Layout.Extensions;
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;




public class EnhancedPopupWindow : PopupWindowContent
{
    // No-op, we do not care about IMGUI
    public override void OnGUI(Rect rect)
    {
    }

    private VisualElement _r;

    public override void OnOpen()
    {
        _r = editorWindow.rootVisualElement;

        // Ensure the window is actually ready for content
        _r.RegisterCallback<AttachToPanelEvent>(evt =>
        {
            var utilStyles = Resources.Load<StyleSheet>("ORLLayoutEditorUtilityStyles");
            var styles = Resources.Load<StyleSheet>("ORLLayoutEditorStyles");
            if (utilStyles != null) _r.styleSheets.Add(utilStyles);
            if (styles != null) _r.styleSheets.Add(styles);
            _r.Add(Render());
        });
    }

    protected virtual VisualElement Render()
    {
        return null;
    }

    protected void ReloadGUI()
    {
        _r.Clear();
        _r.Add(Render());
    }

    protected VStack VStack(params VisualElement[] children)
    {
        return new VStack(children);
    }

    protected HStack HStack(params VisualElement[] children)
    {
        return new HStack(children);
    }

    protected ForEach<T> ForEach<T>(IEnumerable<T> items, Func<T, int, VisualElement> template)
    {
        return new ForEach<T>(items, template);
    }

    protected ForEach<T> ForEach<T>(IEnumerable<T> items, Func<T, VisualElement> template)
    {
        return new ForEach<T>(items, template);
    }

    protected Label Label(string text)
    {
        return new Label(text);
    }

    protected Label Label()
    {
        return new Label();
    }

    protected Button Button()
    {
        return new Button();
    }

    protected Button Button(Action clickEvent)
    {
        return new Button(clickEvent);
    }

    protected Button Button(string label, Action clickEvent)
    {
        return new Button(clickEvent)
        {
            text = label
        };
    }

    protected Foldout Foldout()
    {
        return new Foldout();
    }

    protected ScrollView ScrollView()
    {
        return new ScrollView();
    }

    protected PropertyField PropertyField()
    {
        return new PropertyField();
    }

    protected PropertyField PropertyField(SerializedProperty prop)
    {
        return new PropertyField(prop);
    }

    protected PropertyField PropertyField(SerializedProperty prop, string label)
    {
        return new PropertyField(prop, label);
    }

    protected Toggle Toggle()
    {
        return new Toggle();
    }

    protected Toggle Toggle(string label)
    {
        return new Toggle(label);
    }

    protected IntegerField IntegerField()
    {
        return new IntegerField();
    }

    protected IntegerField IntegerField(string label)
    {
        return new IntegerField(label);
    }

    protected IntegerField IntegerField(string label, int defaultValue)
    {
        return new IntegerField(label, defaultValue);
    }

    protected FloatField FloatField()
    {
        return new FloatField();
    }

    protected FloatField FloatField(string label)
    {
        return new FloatField(label);
    }

    protected FloatField FloatField(int maxLimit)
    {
        return new FloatField(maxLimit);
    }

    protected FloatField FloatField(string label, int maxLimit)
    {
        return new FloatField(label, maxLimit);
    }

    protected TextField TextField()
    {
        return new TextField();
    }

    protected TextField TextField(string label)
    {
        return new TextField(label);
    }

    protected ObjectField ObjectField()
    {
        return new ObjectField();
    }

    protected ObjectField ObjectField(string label)
    {
        return new ObjectField(label);
    }

    protected EnumField EnumField()
    {
        return new EnumField();
    }

    protected EnumField EnumField(string label)
    {
        return new EnumField(label);
    }

    protected EnumField EnumField(string label, Enum defaultValue)
    {
        return new EnumField(label, defaultValue);
    }

    protected Vector2Field Vector2Field()
    {
        return new Vector2Field();
    }

    protected Vector2Field Vector2Field(string label)
    {
        return new Vector2Field(label);
    }

    protected Vector3Field Vector3Field()
    {
        return new Vector3Field();
    }

    protected Vector3Field Vector3Field(string label)
    {
        return new Vector3Field(label);
    }

    protected Vector4Field Vector4Field()
    {
        return new Vector4Field();
    }

    protected Vector4Field Vector4Field(string label)
    {
        return new Vector4Field(label);
    }

    protected ColorField ColorField()
    {
        return new ColorField();
    }

    protected ColorField ColorField(string label)
    {
        return new ColorField(label);
    }

    protected GradientField GradientField()
    {
        return new GradientField();
    }

    protected GradientField GradientField(string label)
    {
        return new GradientField(label);
    }

    protected BoundsField BoundsField()
    {
        return new BoundsField();
    }

    protected BoundsField BoundsField(string label)
    {
        return new BoundsField(label);
    }

    protected RectField RectField()
    {
        return new RectField();
    }

    protected RectField RectField(string label)
    {
        return new RectField(label);
    }

    protected MinMaxSlider MinMaxSlider()
    {
        return new MinMaxSlider();
    }

    protected MinMaxSlider MinMaxSlider(string label)
    {
        return new MinMaxSlider(label);
    }

    protected MinMaxSlider MinMaxSlider(string label, float min, float max)
    {
        return new MinMaxSlider(label, min, max);
    }

    protected MinMaxSlider MinMaxSlider(string label, float min, float max, float minLimit, float maxLimit)
    {
        return new MinMaxSlider(label, min, max, minLimit, maxLimit);
    }

    protected Vector2IntField Vector2IntField()
    {
        return new Vector2IntField();
    }

    protected Vector2IntField Vector2IntField(string label)
    {
        return new Vector2IntField(label);
    }

    protected Vector3IntField Vector3IntField()
    {
        return new Vector3IntField();
    }

    protected Vector3IntField Vector3IntField(string label)
    {
        return new Vector3IntField(label);
    }
}

// EnhancedEditor.cs
namespace ORL.Layout
{
    public partial class EnhancedEditor : Editor
    {
        private VisualElement _r;

        public override VisualElement CreateInspectorGUI()
        {
            _r = new VisualElement();
            var utilStyles = Resources.Load<StyleSheet>("ORLLayoutEditorUtilityStyles");
            var styles = Resources.Load<StyleSheet>("ORLLayoutEditorStyles");
            if (utilStyles != null) _r.styleSheets.Add(utilStyles);
            if (styles != null) _r.styleSheets.Add(styles);
            serializedObject.Update();
            _r.Add(Render());
            return _r;
        }

        protected virtual VisualElement Render()
        {
            return null;
        }

        protected void ReloadGUI()
        {
            _r.Clear();
            _r.Add(Render());
        }

        protected VStack VStack(params VisualElement[] children)
        {
            return new VStack(children);
        }

        protected HStack HStack(params VisualElement[] children)
        {
            return new HStack(children);
        }

        protected ForEach<T> ForEach<T>(IEnumerable<T> items, Func<T, int, VisualElement> template)
        {
            return new ForEach<T>(items, template);
        }

        protected ForEach<T> ForEach<T>(IEnumerable<T> items, Func<T, VisualElement> template)
        {
            return new ForEach<T>(items, template);
        }

        protected Label Label(string text)
        {
            return new Label(text);
        }

        protected Label Label()
        {
            return new Label();
        }

        protected Button Button()
        {
            return new Button();
        }

        protected Button Button(Action clickEvent)
        {
            return new Button(clickEvent);
        }

        protected Button Button(string label, Action clickEvent)
        {
            return new Button(clickEvent)
            {
                text = label
            };
        }

        protected Foldout Foldout()
        {
            return new Foldout();
        }

        protected ScrollView ScrollView()
        {
            return new ScrollView();
        }

        protected PropertyField PropertyField()
        {
            return new PropertyField();
        }

        protected PropertyField PropertyField(SerializedProperty prop)
        {
            return new PropertyField(prop);
        }

        protected PropertyField PropertyField(SerializedProperty prop, string label)
        {
            return new PropertyField(prop, label);
        }

        protected Toggle Toggle()
        {
            return new Toggle();
        }

        protected Toggle Toggle(string label)
        {
            return new Toggle(label);
        }

        protected IntegerField IntegerField()
        {
            return new IntegerField();
        }

        protected IntegerField IntegerField(string label)
        {
            return new IntegerField(label);
        }

        protected IntegerField IntegerField(string label, int defaultValue)
        {
            return new IntegerField(label, defaultValue);
        }

        protected FloatField FloatField()
        {
            return new FloatField();
        }

        protected FloatField FloatField(string label)
        {
            return new FloatField(label);
        }

        protected FloatField FloatField(int maxLimit)
        {
            return new FloatField(maxLimit);
        }

        protected FloatField FloatField(string label, int maxLimit)
        {
            return new FloatField(label, maxLimit);
        }

        protected TextField TextField()
        {
            return new TextField();
        }

        protected TextField TextField(string label)
        {
            return new TextField(label);
        }

        protected ObjectField ObjectField()
        {
            return new ObjectField();
        }

        protected ObjectField ObjectField(string label)
        {
            return new ObjectField(label);
        }

        protected EnumField EnumField()
        {
            return new EnumField();
        }

        protected EnumField EnumField(string label)
        {
            return new EnumField(label);
        }

        protected EnumField EnumField(string label, Enum defaultValue)
        {
            return new EnumField(label, defaultValue);
        }

        protected Vector2Field Vector2Field()
        {
            return new Vector2Field();
        }

        protected Vector2Field Vector2Field(string label)
        {
            return new Vector2Field(label);
        }

        protected Vector3Field Vector3Field()
        {
            return new Vector3Field();
        }

        protected Vector3Field Vector3Field(string label)
        {
            return new Vector3Field(label);
        }

        protected Vector4Field Vector4Field()
        {
            return new Vector4Field();
        }

        protected Vector4Field Vector4Field(string label)
        {
            return new Vector4Field(label);
        }

        protected ColorField ColorField()
        {
            return new ColorField();
        }

        protected ColorField ColorField(string label)
        {
            return new ColorField(label);
        }

        protected GradientField GradientField()
        {
            return new GradientField();
        }

        protected GradientField GradientField(string label)
        {
            return new GradientField(label);
        }

        protected BoundsField BoundsField()
        {
            return new BoundsField();
        }

        protected BoundsField BoundsField(string label)
        {
            return new BoundsField(label);
        }

        protected RectField RectField()
        {
            return new RectField();
        }

        protected RectField RectField(string label)
        {
            return new RectField(label);
        }

        protected MinMaxSlider MinMaxSlider()
        {
            return new MinMaxSlider();
        }

        protected MinMaxSlider MinMaxSlider(string label)
        {
            return new MinMaxSlider(label);
        }

        protected MinMaxSlider MinMaxSlider(string label, float min, float max)
        {
            return new MinMaxSlider(label, min, max);
        }

        protected MinMaxSlider MinMaxSlider(string label, float min, float max, float minLimit, float maxLimit)
        {
            return new MinMaxSlider(label, min, max, minLimit, maxLimit);
        }

        protected Vector2IntField Vector2IntField()
        {
            return new Vector2IntField();
        }

        protected Vector2IntField Vector2IntField(string label)
        {
            return new Vector2IntField(label);
        }

        protected Vector3IntField Vector3IntField()
        {
            return new Vector3IntField();
        }

        protected Vector3IntField Vector3IntField(string label)
        {
            return new Vector3IntField(label);
        }
    }
}

// EnhancedEditorWindow.cs
namespace ORL.Layout
{
    public partial class EnhancedEditorWindow : EditorWindow
    {
        protected VisualElement _r;

        protected void CreateGUI()
        {
            _r = rootVisualElement;
            var utilStyles = Resources.Load<StyleSheet>("ORLLayoutEditorUtilityStyles");
            var styles = Resources.Load<StyleSheet>("ORLLayoutEditorStyles");
            if (utilStyles != null) _r.styleSheets.Add(utilStyles);
            if (styles != null) _r.styleSheets.Add(styles);
            _r.Add(Render());
        }

        protected virtual VisualElement Render()
        {
            return null;
        }

        protected void ReloadGUI()
        {
            _r.Clear();
            _r.Add(Render());
        }

        protected VStack VStack(params VisualElement[] children)
        {
            return new VStack(children);
        }

        protected HStack HStack(params VisualElement[] children)
        {
            return new HStack(children);
        }

        protected ForEach<T> ForEach<T>(IEnumerable<T> items, Func<T, int, VisualElement> template)
        {
            return new ForEach<T>(items, template);
        }

        protected ForEach<T> ForEach<T>(IEnumerable<T> items, Func<T, VisualElement> template)
        {
            return new ForEach<T>(items, template);
        }

        protected Label Label(string text)
        {
            return new Label(text);
        }

        protected Label Label()
        {
            return new Label();
        }

        protected Button Button()
        {
            return new Button();
        }

        protected Button Button(Action clickEvent)
        {
            return new Button(clickEvent);
        }

        protected Button Button(string label, Action clickEvent)
        {
            return new Button(clickEvent)
            {
                text = label
            };
        }

        protected Foldout Foldout()
        {
            return new Foldout();
        }

        protected ScrollView ScrollView()
        {
            return new ScrollView();
        }

        protected PropertyField PropertyField()
        {
            return new PropertyField();
        }

        protected PropertyField PropertyField(SerializedProperty prop)
        {
            return new PropertyField(prop);
        }

        protected PropertyField PropertyField(SerializedProperty prop, string label)
        {
            return new PropertyField(prop, label);
        }

        protected Toggle Toggle()
        {
            return new Toggle();
        }

        protected Toggle Toggle(string label)
        {
            return new Toggle(label);
        }

        protected IntegerField IntegerField()
        {
            return new IntegerField();
        }

        protected IntegerField IntegerField(string label)
        {
            return new IntegerField(label);
        }

        protected IntegerField IntegerField(string label, int defaultValue)
        {
            return new IntegerField(label, defaultValue);
        }

        protected FloatField FloatField()
        {
            return new FloatField();
        }

        protected FloatField FloatField(string label)
        {
            return new FloatField(label);
        }

        protected FloatField FloatField(int maxLimit)
        {
            return new FloatField(maxLimit);
        }

        protected FloatField FloatField(string label, int maxLimit)
        {
            return new FloatField(label, maxLimit);
        }

        protected TextField TextField()
        {
            return new TextField();
        }

        protected TextField TextField(string label)
        {
            return new TextField(label);
        }

        protected ObjectField ObjectField()
        {
            return new ObjectField();
        }

        protected ObjectField ObjectField(string label)
        {
            return new ObjectField(label);
        }

        protected EnumField EnumField()
        {
            return new EnumField();
        }

        protected EnumField EnumField(string label)
        {
            return new EnumField(label);
        }

        protected EnumField EnumField(string label, Enum defaultValue)
        {
            return new EnumField(label, defaultValue);
        }

        protected Vector2Field Vector2Field()
        {
            return new Vector2Field();
        }

        protected Vector2Field Vector2Field(string label)
        {
            return new Vector2Field(label);
        }

        protected Vector3Field Vector3Field()
        {
            return new Vector3Field();
        }

        protected Vector3Field Vector3Field(string label)
        {
            return new Vector3Field(label);
        }

        protected Vector4Field Vector4Field()
        {
            return new Vector4Field();
        }

        protected Vector4Field Vector4Field(string label)
        {
            return new Vector4Field(label);
        }

        protected ColorField ColorField()
        {
            return new ColorField();
        }

        protected ColorField ColorField(string label)
        {
            return new ColorField(label);
        }

        protected GradientField GradientField()
        {
            return new GradientField();
        }

        protected GradientField GradientField(string label)
        {
            return new GradientField(label);
        }

        protected BoundsField BoundsField()
        {
            return new BoundsField();
        }

        protected BoundsField BoundsField(string label)
        {
            return new BoundsField(label);
        }

        protected RectField RectField()
        {
            return new RectField();
        }

        protected RectField RectField(string label)
        {
            return new RectField(label);
        }

        protected MinMaxSlider MinMaxSlider()
        {
            return new MinMaxSlider();
        }

        protected MinMaxSlider MinMaxSlider(string label)
        {
            return new MinMaxSlider(label);
        }

        protected MinMaxSlider MinMaxSlider(string label, float min, float max)
        {
            return new MinMaxSlider(label, min, max);
        }

        protected MinMaxSlider MinMaxSlider(string label, float min, float max, float minLimit, float maxLimit)
        {
            return new MinMaxSlider(label, min, max, minLimit, maxLimit);
        }

        protected Vector2IntField Vector2IntField()
        {
            return new Vector2IntField();
        }

        protected Vector2IntField Vector2IntField(string label)
        {
            return new Vector2IntField(label);
        }

        protected Vector3IntField Vector3IntField()
        {
            return new Vector3IntField();
        }

        protected Vector3IntField Vector3IntField(string label)
        {
            return new Vector3IntField(label);
        }
    }
}

// ReactiveProperty.cs
namespace ORL.Layout
{
    public class ReactiveProperty<T>
    {
        public T Value { get; private set; }
        public event Action<T> OnValueChanged;

        public ReactiveProperty<T> Set(T value)
        {
            if (_targetObject != null)
            {
                Undo.RecordObject(_targetObject, $"Updated Property Value");
            }
            OnValueChanged?.Invoke(value);
            Value = value;
            return this;
        }

        public ReactiveProperty()
        {
            Value = default;
        }

        public ReactiveProperty(T value = default)
        {
            Value = value;
        }

        public static implicit operator T(ReactiveProperty<T> property)
        {
            return property.Value;
        }

        public ReactiveProperty<T> OnChanged(Action<T> action)
        {
            OnValueChanged += action;
            return this;
        }

        private UnityEngine.Object _targetObject;

        public ReactiveProperty<T> BindToObject(UnityEngine.Object targetObject)
        {
            _targetObject = targetObject;
            return this;
        }

        private void SaveToProperty(SerializedProperty property, object value)
        {
            switch (property.propertyType)
            {
                case SerializedPropertyType.Integer:
                    property.intValue = Convert.ToInt32(value);
                    break;
                case SerializedPropertyType.Boolean:
                    property.boolValue = Convert.ToBoolean(value);
                    break;
                case SerializedPropertyType.Float:
                    property.floatValue = Convert.ToSingle(value);
                    break;
                case SerializedPropertyType.String:
                    property.stringValue = Convert.ToString(value);
                    break;
                case SerializedPropertyType.Enum:
                    property.enumValueIndex = Convert.ToInt32(value);
                    break;
                case SerializedPropertyType.ObjectReference:
                    property.objectReferenceValue = value as UnityEngine.Object;
                    break;
                case SerializedPropertyType.LayerMask:
                    if (value is LayerMask mask)
                    {
                        property.intValue = mask.value;
                    }
                    break;
                case SerializedPropertyType.Vector2:
                    if (value is Vector2 vector2)
                    {
                        property.vector2Value = vector2;
                    }
                    break;
                case SerializedPropertyType.Vector3:
                    if (value is Vector3 vector3)
                    {
                        property.vector3Value = vector3;
                    }
                    break;
                case SerializedPropertyType.Vector4:
                    if (value is Vector4 vector4)
                    {
                        property.vector4Value = vector4;
                    }
                    break;
                case SerializedPropertyType.Rect:
                    if (value is Rect rect)
                    {
                        property.rectValue = rect;
                    }
                    break;
                case SerializedPropertyType.ArraySize:
                    property.arraySize = Convert.ToInt32(value);
                    break;
                case SerializedPropertyType.Character:
                    if (value is char character)
                    {
                        property.intValue = character;
                    }
                    break;
                case SerializedPropertyType.AnimationCurve:
                    if (value is AnimationCurve curve)
                    {
                        property.animationCurveValue = curve;
                    }
                    break;
                case SerializedPropertyType.Bounds:
                    if (value is Bounds bounds)
                    {
                        property.boundsValue = bounds;
                    }
                    break;
                case SerializedPropertyType.Quaternion:
                    if (value is Quaternion quaternion)
                    {
                        property.quaternionValue = quaternion;
                    }
                    break;
                case SerializedPropertyType.ExposedReference:
                    if (value is UnityEngine.Object obj)
                    {
                        property.exposedReferenceValue = obj;
                    }
                    break;
                case SerializedPropertyType.Color:
                    if (value is Color color)
                    {
                        property.colorValue = color;
                    }
                    break;
                case SerializedPropertyType.Vector2Int:
                    if (value is Vector2Int vector2Int)
                    {
                        property.vector2IntValue = vector2Int;
                    }
                    break;
                case SerializedPropertyType.Vector3Int:
                    if (value is Vector3Int vector3Int)
                    {
                        property.vector3IntValue = vector3Int;
                    }
                    break;
                case SerializedPropertyType.RectInt:
                    if (value is RectInt rectInt)
                    {
                        property.rectIntValue = rectInt;
                    }
                    break;
                case SerializedPropertyType.BoundsInt:
                    if (value is BoundsInt boundsInt)
                    {
                        property.boundsIntValue = boundsInt;
                    }
                    break;
                default:
                    Debug.LogWarning($"Property type {property.propertyType} is not supported by ReactiveProperty binding");
                    break;
            }
        }

        public ReactiveProperty<T> BindToProperty(SerializedProperty property)
        {
            OnValueChanged += value =>
            {
                var tType = typeof(T);
                var isArray = tType.IsArray || tType.IsGenericType && tType.GetGenericTypeDefinition() == typeof(List<>);
                if (isArray && property.isArray)
                {
                    var arrayElementType = tType.IsArray ? tType.GetElementType() : tType.GetGenericArguments()[0];
                    if (arrayElementType == null)
                    {
                        Debug.LogWarning($"Could not determine array element type for {tType}");
                        return;
                    }

                    if (arrayElementType.Name.ToLowerInvariant() != property.arrayElementType)
                    {
                        Debug.LogWarning($"Array element type mismatch: {arrayElementType.Name} != {property.arrayElementType}");
                        return;
                    }

                    if (tType.IsArray)
                    {
                        property.arraySize = (value as Array).Length;
                        for (int i = 0; i < (value as Array).Length; i++)
                        {
                            var el = property.GetArrayElementAtIndex(i);
                            SaveToProperty(el, (value as Array).GetValue(i));
                        }
                    }
                    else
                    {
                        property.arraySize = (value as System.Collections.IList).Count;
                        for (int i = 0; i < (value as System.Collections.IList).Count; i++)
                        {
                            var el = property.GetArrayElementAtIndex(i);
                            SaveToProperty(el, (value as System.Collections.IList)[i]);
                        }
                    }
                }
                else if (property.propertyType == SerializedPropertyType.Generic)
                {
                    Debug.LogWarning($"Property type {property.propertyType} is not supported by ReactiveProperty binding");
                }
                else
                {
                    SaveToProperty(property, value);
                }

                property.serializedObject.ApplyModifiedProperties();
            };
            return this;
        }
    }
}

// Elements/ForEach.cs
namespace ORL.Layout.Elements
{
    /// <summary>
    /// Iterator element that creates a visual element for each item in the provided collection using provided template function
    /// </summary>
    /// <typeparam name="T">Item type</typeparam>
    public class ForEach<T> : VisualElement
    {
        private List<VisualElement> _elements = new List<VisualElement>();
        private Func<T, VisualElement> _templateFunc;
        private Func<T, int, VisualElement> _templateFuncWithIndex;
        private bool _attached;

        /// <summary>
        /// Creates a new instance of ForEach element
        /// </summary>
        /// <example>
        /// <code>
        /// var items = new List<string> { "Item 1", "Item 2", "Item 3" };
        /// return VStack(
        ///     ForEach(items, item => new Label(item))
        /// );
        /// </code>
        /// </example>
        /// <param name="items">An `IEnumerable<T>` of items to use</param>
        /// <param name="template">A `Func<T, VisualElement>` template function that renders an individual element</param>
        public ForEach(IEnumerable<T> items, Func<T, VisualElement> template)
        {
            _templateFunc = template;
            UpdateElements(items);
        }

        /// <summary>
        /// Creates a new instance of ForEach element passing element index to the template function
        /// </summary>
        /// <example>
        /// <code>
        /// var items = new List<string> { "Item 1", "Item 2", "Item 3" };
        /// return VStack(
        ///     ForEach(items, (item, index) => new Label($"[{index}] {item}"))
        /// );
        /// </code>
        /// </example>
        /// <param name="items">An `IEnumerable<T>` of items to use</param>
        /// <param name="template">A `Func<T, int, VisualElement>` template function that renders an individual element, has access to the element's index in the original collection</param>
        public ForEach(IEnumerable<T> items, Func<T, int, VisualElement> template)
        {
            _templateFuncWithIndex = template;
            UpdateElements(items);
        }

        private void InsertElements()
        {
            var insertAt = hierarchy.parent.hierarchy.IndexOf(this);
            foreach (var item in _elements)
            {
                hierarchy.parent.Insert(insertAt, item);
            }
        }

        private void UpdateElements(IEnumerable<T> items)
        {
            _elements.ForEach(e => e.RemoveFromHierarchy());
            _elements.Clear();

            if (_templateFunc != null)
            {
                foreach (var item in items)
                {
                    _elements.Add(_templateFunc(item));
                }
            }
            else
            {
                var i = 0;
                foreach (var item in items)
                {
                    _elements.Add(_templateFuncWithIndex(item, i));
                    i++;
                }
            }

            _elements.Reverse();

            if (!_attached)
            {
                RegisterCallback<AttachToPanelEvent>(_ =>
                {
                    _attached = true;
                    InsertElements();
                });
            }
            else
            {
                InsertElements();
            }
        }

        /// <summary>
        /// Binds the ForEach element to a reactive property of `IEnumerable<T>` type. This automatically re-renders the elements on property change
        /// </summary>
        /// <list>
        /// <item>The current implementation only re-renders when `.Set` is called on the reactive property</item>
        /// </list>
        /// <example>
        /// <code>
        /// var items = new ReactiveProperty<IEnumerable<string>>(new List<string> { "Item 1", "Item 2", "Item 3" });
        /// return VStack(
        ///    ForEach(items.Value, item => new Label(item)).BoundToProp(items),
        ///    Button("Add Item").OnClick(() => { items.Set(new List<string>(items.Value) { "New Item" }); })
        /// );
        /// </code>
        /// </example>
        /// <param name="prop">`ReactiveProperty<IEnumerable<T>>` to bind to</param>
        /// <returns></returns>
        public ForEach<T> BoundToProp(ReactiveProperty<IEnumerable<T>> prop)
        {
            prop.OnValueChanged += s => UpdateElements(s);
            return this;
        }

        /// <summary>
        /// Binds the ForEach element to a reactive property of `IEnumerable<T>` type with a custom transform function. This automatically re-renders the elements on property change
        /// </summary>
        /// <list>
        /// <item>The current implementation only re-renders when `.Set` is called on the reactive property</item>
        /// <item>The `transform` function can be used to prepare elements to be rendered by the `template` function</item>
        /// </list>
        /// <example>
        /// <code>
        /// var items = new ReactiveProperty<IEnumerable<string>>(new List<string> { "Item 1", "Item 2", "Item 3" });
        /// return VStack(
        ///    ForEach(items.Value, item => new Label(item)).BoundToProp(items, items => items.Reverse()),
        ///    Button("Add Item").OnClick(() => { items.Set(new List<string>(items.Value) { "New Item" }); })
        /// );
        /// </code>
        /// </example>
        /// <param name="prop">`ReactiveProperty<IEnumerable<T>>` to bind to</param>
        /// <param name="transform">A `Func<IEnumerable<T>, IEnumerable<T>>` transform function that prepares the elements to be rendered by the `template` function</param>
        /// <returns></returns>
        public ForEach<T> BoundToProp(ReactiveProperty<IEnumerable<T>> prop, Func<IEnumerable<T>, IEnumerable<T>> transform)
        {
            prop.OnValueChanged += s => UpdateElements(transform(s));
            return this;
        }

        public ForEach<T> BoundToProp(ReactiveProperty<List<T>> prop)
        {
            prop.OnValueChanged += s => UpdateElements(s);
            return this;
        }

        public ForEach<T> BoundToProp(ReactiveProperty<List<T>> prop, Func<IEnumerable<T>, List<T>> transform)
        {
            prop.OnValueChanged += s => UpdateElements(transform(s));
            return this;
        }
    }
}

// Elements/HStack.cs
namespace ORL.Layout.Elements
{
    public class HStack : VisualElement
    {
        public HStack()
        {
            this.Direction(FlexDirection.Row);
        }

        public HStack(params VisualElement[] children) : this()
        {
            this.Children(children);
        }
    }
}

// Elements/VStack.cs
namespace ORL.Layout.Elements
{
    public class VStack : VisualElement
    {
        public VStack()
        {
            this.Direction(FlexDirection.Column);
        }

        public VStack(params VisualElement[] children) : this()
        {
            this.Children(children);
        }
    }
}

// Extensions/ButtonExtensions.cs
namespace ORL.Layout.Extensions
{
    public static partial class ButtonExtensions
    {
        /// <summary>
        /// Binds a click event to the button
        /// </summary>
        /// <example>
        /// <code>
        /// Button().Text("Click me").OnClick(() => Debug.Log("Clicked!"));
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="onClick">Click `Action`</param>
        /// <returns></returns>
        public static Button OnClick(this Button el, Action onClick)
        {
            el.clicked += onClick;
            return el;
        }

        /// <summary>
        /// Opens a popup window when the button is clicked
        /// </summary>
        /// <example>
        /// <code>
        /// Button().Text("Open Popup").OpenPopup(new TestPopup());
        /// </code>
        /// </example>
        /// <list>
        /// <item>You can use `EnhancedPopupWindow` to create popups with OTK as well</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="popup"></param>
        /// <returns></returns>
        public static Button OpenPopup(this Button el, PopupWindowContent popup)
        {
            el.clicked += () => UnityEditor.PopupWindow.Show(el.worldBound, popup);
            return el;
        }
    }
}

// Extensions/FoldoutExtensions.cs
namespace ORL.Layout.Extensions
{
    public static partial class FoldoutExtensions
    {
        /// <summary>
        /// Sets the text of the foldout
        /// </summary>
        /// <example>
        /// <code>
        /// Foldout().Text("Foldout text");
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="text"></param>
        /// <returns></returns>
        public static Foldout Text(this Foldout el, string text)
        {
            el.text = text;
            return el;
        }
    }
}

// Extensions/NotifiableFieldsExtensions.cs
namespace ORL.Layout.Extensions
{
    public static partial class NotifiableFieldExtensions
    {
        /// <summary>
        /// Binds a property to the value of the field
        /// </summary>
        /// <example>
        /// <code>
        /// private ReactiveProperty<string> _text = new("Hello");
        /// 
        /// protected override VisualElement Render()
        /// {
        ///     return VStack(
        ///         TextField("Type some text!").BoundPropValue(_text),
        ///         Label().BoundPropText(_text)
        ///     );
        /// }
        /// </code>
        /// </example>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="SType"></typeparam>
        /// <param name="el"></param>
        /// <param name="prop">`ReactiveProperty<T>` to bind to, must match the field type</param>
        /// <returns></returns>
        public static T BoundPropValue<T, SType>(this T el, ReactiveProperty<SType> prop) where T : INotifyValueChanged<SType>
        {
            el.value = prop.Value;
            el.RegisterValueChangedCallback(s =>
            {
                prop.Set(s.newValue);
            });
            // Ensure two-way communication
            prop.OnValueChanged += s => el.value = s;
            return el;
        }

        /// <summary>
        /// Binds a generic callback to the value change event
        /// </summary>
        /// <example>
        /// <code>
        /// TextField("Type some text").OnChange(e => Debug.Log(e.newValue));
        /// </code>
        /// </example>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="SType"></typeparam>
        /// <param name="el"></param>
        /// <param name="onChange">`ChangeEvent` callback to bind</param>
        /// <returns></returns>
        public static T OnChange<T, SType>(this T el, EventCallback<ChangeEvent<SType>> onChange) where T : INotifyValueChanged<SType>
        {
            el.RegisterValueChangedCallback(onChange);
            return el;
        }

    }
}

// Extensions/TextElementExtensions.cs
namespace ORL.Layout.Extensions
{
    public static partial class TextElementExtensions
    {
        /// <summary>
        /// Sets the text of a TextElement
        /// </summary>
        /// <example>
        /// <code>
        /// Button().Text("Click me!");
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="text"></param>
        /// <returns></returns>
        public static T Text<T>(this T el, string text) where T : TextElement
        {
            el.text = text;
            return el;
        }

        /// <summary>
        /// Binds a `ReactiveProperty` to the text of a TextElement.
        /// This will automatically update the text when the property changes via its `.Set()` method
        /// </summary>
        /// <example>
        /// <code>
        /// private ReactiveProperty<string> _text = new("Waiting");
        /// 
        /// protected override VisualElement Render()
        /// {
        ///     return VStack(
        ///         Label().BoundPropValue(_text),
        ///         Button(() => _text.Set("Thank you!")).Text("Click me!")
        ///     );
        /// }
        /// </code>
        /// </example>
        /// <typeparam name="T"></typeparam>
        /// <param name="el"></param>
        /// <param name="prop">`ReactiveProperty<string>` to bind to</param>
        /// <returns></returns>
        public static T BoundPropText<T>(this T el, ReactiveProperty<string> prop) where T : TextElement
        {
            el.text = prop.Value;
            prop.OnValueChanged += s => el.text = s;
            return el;
        }

        /// <summary>
        /// Binds a `ReactiveProperty` to the text of a TextElement via a custom compute function.
        /// This will automatically update the text when the property changes via its `.Set()` method
        /// </summary>
        /// <example>
        /// <code>
        /// private ReactiveProperty<int> _counter = new(0);
        /// 
        /// protected override VisualElement Render()
        /// {
        ///     return VStack(
        ///         Label().BoundPropValue(_counter, c => $"Counter: {c}"),
        ///         Button(() => _counter.Set(_counter + 1)).Text("Click me!")
        ///     );
        /// }
        /// </code>
        /// </example>
        /// <typeparam name="T"></typeparam>
        /// <param name="el"></param>
        /// <param name="prop">`ReactiveProperty<T>` to bind to</param>
        /// <param name="compute">Function to compute the text from the property value</param>
        /// <returns></returns>
        public static T BoundPropText<T, SType>(this T el, ReactiveProperty<SType> prop, Func<SType, string> compute) where T : TextElement
        {
            el.text = compute(prop.Value);
            prop.OnValueChanged += s => el.text = compute(s);
            return el;
        }
    }
}

// Extensions/TextFieldExtensions.cs
namespace ORL.Layout.Extensions
{
    public static partial class TextFieldExtensions
    {
        /// <summary>
        /// Sets the value of a string input field
        /// </summary>
        /// <example>
        /// <code>
        /// TextField().Value("Hello, world!");
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static T Value<T>(this T el, string value) where T : TextInputBaseField<string>
        {
            el.value = value;
            return el;
        }

        /// <summary>
        /// Sets any input field to be delayed or not
        /// </summary>
        /// <example>
        /// <code>
        /// TextField().Delayed(true);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static T Delayed<T, SType>(this T el, bool value) where T : TextInputBaseField<SType>
        {
            el.isDelayed = value;
            return el;
        }

        /// <summary>
        /// Sets any input field to be delayed
        /// </summary>
        /// <example>
        /// <code>
        /// TextField().Delayed();
        /// </code>
        /// </example>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="SType"></typeparam>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T Delayed<T, SType>(this T el) where T : TextInputBaseField<SType>
        {
            el.isDelayed = true;
            return el;
        }
    }
}

// Extensions/VisualElementExtensions.cs
namespace ORL.Layout.Extensions
{
    public static partial class VisualElementExtensions
    {
        /// <summary>
        /// Assigns a list of USS classes to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Button().Class("btn", "btn-primary");
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="classNames">List ot class names to add</param>
        /// <returns></returns>
        public static T Class<T>(this T el, params string[] classNames) where T : VisualElement
        {
            foreach (var className in classNames)
            {
                el.AddToClassList(className);
            }
            return el;
        }

        /// <summary>
        /// Adds child elements to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Foldout().Children(
        ///    Label().Text("Hello, world!"),
        ///    Button().Text("Click me!")
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="children"></param>
        /// <returns></returns>
        public static T Children<T>(this T el, params VisualElement[] children) where T : VisualElement
        {
            foreach (var child in children)
            {
                el.Add(child);
            }

            return el;
        }

        /// <summary>
        /// Saves a reference to the created VisualElement in a provided variable reference for future use
        /// </summary>
        /// <example>
        /// <code>
        /// Label label = null;
        /// return VStack(
        ///   Label().Text("Hello, world!").Ref(ref label),
        ///   Button(() => label.text = "Wow, you clicked me!").Text("Click me!")
        /// )
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        public static T Ref<T>(this T el, ref T target) where T : VisualElement
        {
            target = el;
            return el;
        }

        /// <summary>
        /// Stores an arbitary object in the `userData` property of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Label label = null;
        /// return VStack(
        ///     Label("Heyo!").UserData("Secret message!").Ref(ref label),
        ///     Button(() => label.text = label.userData).Text("Reveal secrets!")
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="userData"></param>
        /// <returns></returns>
        public static T UserData<T>(this T el, object userData) where T : VisualElement
        {
            el.userData = userData;
            return el;
        }

        /// <summary>
        /// Assigns a name to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Label().Name("my-label");
        /// </code>
        /// </example>
        /// <list>
        /// <item>This can be used to target elements via USS #selectors, e.g. #my-label</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public static T Name<T>(this T el, string name) where T : VisualElement
        {
            el.name = name;
            return el;
        }

        /// <summary>
        /// Assigns a view data key to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Foldout().ViewDataKey("my-foldout").Children(
        ///    Label().Text("Hello, world!")
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>This enables view state persistence on supported elements, e.g. Foldout or Scrollview. More info on Unity docs</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="viewDataKey"></param>
        /// <returns></returns>
        public static T ViewDataKey<T>(this T el, string viewDataKey) where T : VisualElement
        {
            el.viewDataKey = viewDataKey;
            return el;
        }

        /// <summary>
        /// Enables arbitrary styles manipulation via an `Action<IStyle>` delegate
        /// </summary>
        /// <example>
        /// <code>
        /// Label("Text with background color").Style(style => style.backgroundColor = Color.red);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="setter">`Action<IStyle>` that manipulates the style object of the target element</param>
        /// <returns></returns>
        public static T Style<T>(this T el, Action<IStyle> setter) where T : VisualElement
        {
            setter(el.style);
            return el;
        }

        /// <summary>
        /// Sets the edge padding of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///    Label("Padded label").Padding(10),
        ///    Label("Another padded label").Padding(5, 10),
        ///    Label("Yet another padded label").Padding(5, 10, 15),
        ///    Label("The last padded label").Padding(5, 10, 15, 20)
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>1 value: sets all paddings to the same value</item>
        /// <item>2 values: sets top and bottom paddings to the first value, left and right paddings to the second value</item>
        /// <item>3 values: sets top padding to the first value, left and right paddings to the second value, bottom padding to the third value</item>
        /// <item>4 values: sets top, right, bottom and left paddings to the respective values</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="padding"></param>
        /// <returns></returns>
        public static T Padding<T>(this T el, params float[] padding) where T : VisualElement
        {
            switch (padding.Length)
            {
                case 1:
                    el.style.paddingTop = padding[0];
                    el.style.paddingRight = padding[0];
                    el.style.paddingBottom = padding[0];
                    el.style.paddingLeft = padding[0];
                    break;
                case 2:
                    el.style.paddingTop = padding[0];
                    el.style.paddingBottom = padding[0];
                    el.style.paddingLeft = padding[1];
                    el.style.paddingRight = padding[1];
                    break;
                case 3:
                    el.style.paddingTop = padding[0];
                    el.style.paddingLeft = padding[1];
                    el.style.paddingRight = padding[1];
                    el.style.paddingBottom = padding[2];
                    break;
                case 4:
                    el.style.paddingTop = padding[0];
                    el.style.paddingRight = padding[1];
                    el.style.paddingBottom = padding[2];
                    el.style.paddingLeft = padding[3];
                    break;
            }

            return el;
        }

        /// <summary>
        /// Sets the edge margin of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///    Label("Offset label").Margin(10),
        ///    Label("Another Offset label").Margin(5, 10),
        ///    Label("Yet another Offset label").Margin(5, 10, 15),
        ///    Label("The last Offset label").Margin(5, 10, 15, 20)
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>1 value: sets all margins to the same value</item>
        /// <item>2 values: sets top and bottom margins to the first value, left and right margins to the second value</item>
        /// <item>3 values: sets top margin to the first value, left and right margins to the second value, bottom margin to the third value</item>
        /// <item>4 values: sets top, right, bottom and left margins to the respective values</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="margin"></param>
        /// <returns></returns>
        public static T Margin<T>(this T el, params float[] margin) where T : VisualElement
        {
            switch (margin.Length)
            {
                case 1:
                    el.style.marginTop = margin[0];
                    el.style.marginRight = margin[0];
                    el.style.marginBottom = margin[0];
                    el.style.marginLeft = margin[0];
                    break;
                case 2:
                    el.style.marginTop = margin[0];
                    el.style.marginBottom = margin[0];
                    el.style.marginLeft = margin[1];
                    el.style.marginRight = margin[1];
                    break;
                case 3:
                    el.style.marginTop = margin[0];
                    el.style.marginLeft = margin[1];
                    el.style.marginRight = margin[1];
                    el.style.marginBottom = margin[2];
                    break;
                case 4:
                    el.style.marginTop = margin[0];
                    el.style.marginRight = margin[1];
                    el.style.marginBottom = margin[2];
                    el.style.marginLeft = margin[3];
                    break;
            }

            return el;
        }

        /// <summary>
        /// Sets the VisualElement's positioning to be parent-relative
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///     Label("I'm relative!").Relative().Top(10)
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>Useful for positioning elements inside a container</item>
        /// </list>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T Relative<T>(this T el) where T : VisualElement
        {
            el.style.position = Position.Relative;
            return el;
        }

        /// <summary>
        /// Sets the VisualElement's positioning to be absolute
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///    Label("I can overlap other elements").Absolute().Top(10).Left(30)
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T Absolute<T>(this T el) where T : VisualElement
        {
            el.style.position = Position.Absolute;
            return el;
        }

        /// <summary>
        /// Adds top offset to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///   Label("I'm 10px offset from the top").Top(10)
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="offset">Amount to offset by</param>
        /// <returns></returns>
        public static T Top<T>(this T el, float offset) where T : VisualElement
        {
            el.style.top = offset;
            return el;
        }

        /// <summary>
        /// Adds left offset to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///   Label("I'm 10px offset from the left").Left(10)
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="offset">Amount to offset by</param>
        /// <returns></returns>
        public static T Left<T>(this T el, float offset) where T : VisualElement
        {
            el.style.top = offset;
            return el;
        }

        /// <summary>
        /// Adds right offset to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///   Label("I'm 10px offset from the right").Right(10)
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="offset">Amount to offset by</param>
        /// <returns></returns>
        public static T Right<T>(this T el, float offset) where T : VisualElement
        {
            el.style.right = offset;
            return el;
        }

        /// <summary>
        /// Adds bottom offset to a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///   Label("I'm 10px offset from the bottom").Bottom(10)
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="offset">Amount to offset by</param>
        /// <returns></returns>
        public static T Bottom<T>(this T el, float offset) where T : VisualElement
        {
            el.style.bottom = offset;
            return el;
        }

        /// <summary>
        /// Sets the VisualElement's flex properties
        /// </summary>
        /// <example>
        /// <code>
        /// HStack(
        ///   TextField("I will grow").Flex(1),
        ///   Button("I will not", () => {})
        /// );
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="size">Flex size to use for ratio-based scaling. See Unity docs for more details</param>
        /// <returns></returns>
        public static T Flex<T>(this T el, float size) where T : VisualElement
        {
            el.style.flexBasis = new StyleLength(new Length(0, LengthUnit.Percent));
            el.style.flexShrink = 1;
            el.style.flexGrow = size;
            return el;
        }

        /// <summary>
        /// Enables word-wrapping on the VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Label("This text will wrap around if it's too long").Wrapped();
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T Wrapped<T>(this T el) where T : VisualElement
        {
            el.style.whiteSpace = WhiteSpace.Normal;
            return el;
        }

        /// <summary>
        /// Makes the VisualElement's text bold
        /// </summary>
        /// <example>
        /// <code>
        /// Label("I'm bold!").Bold();
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T Bold<T>(this T el) where T : VisualElement
        {
            if (el.style.unityFontStyleAndWeight == FontStyle.Italic)
            {
                el.style.unityFontStyleAndWeight = FontStyle.BoldAndItalic;
                return el;
            }

            el.style.unityFontStyleAndWeight = FontStyle.Bold;
            return el;
        }

        /// <summary>
        /// Makes the VisualElement's text italicized
        /// </summary>
        /// <example>
        /// <code>
        /// Label("I'm italic!").Italic();
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T Italic<T>(this T el) where T : VisualElement
        {
            if (el.style.unityFontStyleAndWeight == FontStyle.Bold)
            {
                el.style.unityFontStyleAndWeight = FontStyle.BoldAndItalic;
                return el;
            }

            el.style.unityFontStyleAndWeight = FontStyle.Italic;
            return el;
        }

        /// <summary>
        /// Makes the VisualElement's text bold and italicized
        /// </summary>
        /// <example>
        /// <code>
        /// Label("I'm bold and italic!").BoldItalic();
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <returns></returns>
        public static T BoldItalic<T>(this T el) where T : VisualElement
        {
            el.style.unityFontStyleAndWeight = FontStyle.BoldAndItalic;
            return el;
        }

        /// <summary>
        /// Sets the VisualElement's text color
        /// </summary>
        /// <example>
        /// <code>
        /// Label("I'm red!").Color(Color.red);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="color"></param>
        /// <returns></returns>
        public static T Color<T>(this T el, Color color) where T : VisualElement
        {
            el.style.color = color;
            return el;
        }

        /// <summary>
        /// Sets the width of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// Label("I'm 100px wide").Width(100);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="width"></param>
        /// <returns></returns>
        public static T Width<T>(this T el, float width) where T : VisualElement
        {
            el.style.width = width;
            return el;
        }

        /// <summary>
        /// Sets the VisualElemenet's SerializedObject binding path
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///     TextField("Object's name").BindingPath("name");
        /// ).BindSerializedObject(new SerializedObject(myObject));
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="bindingPath">Variable's binding path. Check Unity docs for more information on IBindable fields</param>
        /// <returns></returns>
        public static T BindingPath<T>(this T el, string bindingPath) where T : IBindable
        {
            el.bindingPath = bindingPath;
            return el;
        }

        /// <summary>
        /// Binds a VisualElement to a SerializedObject
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///    TextField("Object's name").BindingPath("name");
        /// ).BindSerializedObject(new SerializedObject(myObject));
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="serializedObject">SerializedObject to bind to</param>
        /// <returns></returns>
        public static T BindSerializedObject<T>(this T el, SerializedObject serializedObject) where T : VisualElement
        {
            el.Bind(serializedObject);
            return el;
        }

        /// <summary>
        /// Aligns the children of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///   Label("I'm centered"),
        ///   Label("I'm also centered")
        /// ).AlignItems(Align.Center);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="align">Align mode. Check Unity docs for more information</param>
        /// <returns></returns>
        public static T AlignItems<T>(this T el, Align align) where T : VisualElement
        {
            el.style.alignItems = align;
            return el;
        }

        public static T AlignContent<T>(this T el, Align align) where T : VisualElement
        {
            el.style.alignContent = align;
            return el;
        }

        /// <summary>
        /// Justifies the content of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// VStack(
        ///     Label("I'm all the way to the left"),
        ///     Label("I'm all the way to the right")
        /// ).JustifyContent(Justify.SpaceBetween);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="justify">Justify Content mode. Check Unity docs for more information</param>
        /// <returns></returns>
        public static T JustifyContent<T>(this T el, Justify justify) where T : VisualElement
        {
            el.style.justifyContent = justify;
            return el;
        }

        /// <summary>
        /// Controls the direction of VisualElement's child alignment
        /// </summary>
        /// <example>
        /// <code>
        /// VisualElement(
        ///    Label("I'm first"),
        ///    Label("I'm second")
        /// ).Direction(FlexDirection.Row);
        /// </code>
        /// </example>
        /// <param name="el"></param>
        /// <param name="direction">Flex direction for layout</param>
        /// <returns></returns>
        public static T Direction<T>(this T el, FlexDirection direction) where T : VisualElement
        {
            el.style.flexDirection = direction;
            return el;
        }

        /// <summary>
        /// Conditionally shows a VisualElement based on a provided condition function
        /// </summary>
        /// <example>
        /// <code>
        /// var showHelp = false;
        /// VStack(
        ///     Label("Help info here").ShowIf(() => showHelp),
        ///     Button("Toggle Help", () => showHelp = !showHelp)
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>This spools up a timer that evaluates the condition function every 300ms. Use `ReactiveProperty` for more efficient event-based updates</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="condition">`Func<bool>` that returns the visibility state</param>
        /// <returns></returns>
        public static T ShowIf<T>(this T el, Func<bool> condition) where T : VisualElement
        {
            el.style.display = condition() ? DisplayStyle.Flex : DisplayStyle.None;
            el.schedule.Execute(() => el.style.display = condition() ? DisplayStyle.Flex : DisplayStyle.None).Every(300);
            return el;
        }

        /// <summary>
        /// Conditionally hides a VisualElement based on a provided condition function
        /// </summary>
        /// <example>
        /// <code>
        /// var simpleMode = false;
        /// VStack(
        ///    Label("Advanced information").HideIf(() => simpleMode),
        ///    Button("Simple Mode", () => simpleMode = !simpleMode)
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>This spools up a timer that evaluates the condition function every 300ms. Use `ReactiveProperty` for more efficient event-based updates</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="condition">`Func<bool>` that returns the hidden state</param>
        /// <returns></returns>
        public static T HideIf<T>(this T el, Func<bool> condition) where T : VisualElement
        {
            el.style.display = condition() ? DisplayStyle.None : DisplayStyle.Flex;
            el.schedule.Execute(() => el.style.display = condition() ? DisplayStyle.None : DisplayStyle.Flex).Every(300);
            return el;
        }

        /// <summary>
        /// Binds visbility state of a VisualElement
        /// </summary>
        /// <example>
        /// <code>
        /// var isVisible = new ReactiveProperty<bool>(true);
        /// VStack(
        ///     Label("Toggle Me").BindVisibleState(isVisible),
        ///     Button("Toggle visibility", () => isVisible.Set(!isVisible.Value))
        /// );
        /// </code>
        /// </example>
        /// <list>
        /// <item>Compared to `HideIf` and `ShowIf` this only updates the visibility state when the value changes</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="prop">`ReactiveProperty<bool>` to bind to</param>
        /// <returns></returns>
        public static T BindVisibleState<T>(this T el, ReactiveProperty<bool> prop) where T : VisualElement
        {
            el.style.display = prop.Value ? DisplayStyle.Flex : DisplayStyle.None;
            prop.OnValueChanged += value => el.style.display = value ? DisplayStyle.Flex : DisplayStyle.None;
            return el;
        }

        /// <summary>
        /// Calls a provided callback on mount
        /// </summary>
        /// <example>
        /// <code>
        /// VisualElement().OnMount(label => Debug.Log("Label mounted!"));
        /// </code>
        /// </example>
        /// <list>
        /// <item>This is internally called on `AttachToPanelEvent`</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="onMount">An `Action<T>` function that receives the element reference on mount</param>
        /// <returns></returns>
        public static T OnMount<T>(this T el, Action<T> onMount) where T : VisualElement
        {
            el.RegisterCallback<AttachToPanelEvent>(e => onMount(el));
            return el;
        }

        /// <summary>
        /// Calls a provided callback on unmount
        /// </summary>
        /// <example>
        /// <code>
        /// VisualElement().OnUnmount(label => Debug.Log("Label unmounted!"));
        /// </code>
        /// </example>
        /// <list>
        /// <item>This is internally called on `DetachFromPanelEvent`</item>
        /// </list>
        /// <param name="el"></param>
        /// <param name="onUnmount">An `Action<T>` function that receives the element reference on unmount</param>
        /// <returns></returns>
        public static T OnUnmount<T>(this T el, Action<T> onUnmount) where T : VisualElement
        {
            el.RegisterCallback<DetachFromPanelEvent>(e => onUnmount(el));
            return el;
        }
    }
}
