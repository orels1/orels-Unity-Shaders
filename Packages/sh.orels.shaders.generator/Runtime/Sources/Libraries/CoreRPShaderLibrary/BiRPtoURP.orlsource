%LibraryFunctions()
{
    //--------------------------------------------------------------
    // Macros to redefine built-in macros to those used by the URP
    //--------------------------------------------------------------

    #if !defined(BIRP_TO_URP)
    #define BIRP_TO_URP

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    // StdLib.hlsl ----------------------------------------------------------------
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------

    #define HALF_MAX        65504.0 // (2 - 2^-10) * 2^15
    #define HALF_MAX_MINUS1 65472.0 // (2 - 2^-9) * 2^15
    #define EPSILON         1.0e-4
    #define PI              3.14159265359
    #define TWO_PI          6.28318530718
    #define FOUR_PI         12.56637061436
    #define INV_PI          0.31830988618
    #define INV_TWO_PI      0.15915494309
    #define INV_FOUR_PI     0.07957747155
    #define HALF_PI         1.57079632679
    #define INV_HALF_PI     0.636619772367

    #define FLT_EPSILON     1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0
    #define FLT_MIN         1.175494351e-38 // Minimum representable positive floating-point number
    #define FLT_MAX         3.402823466e+38 // Maximum representable floating-point number



    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    // Common.hlsl ----------------------------------------------------------------
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    /*
    #define half min16float
    #define half2 min16float2
    #define half3 min16float3
    #define half4 min16float4
    #define half2x2 min16float2x2
    #define half2x3 min16float2x3
    #define half3x2 min16float3x2
    #define half3x3 min16float3x3
    #define half3x4 min16float3x4
    #define half4x3 min16float4x3
    #define half4x4 min16float4x4
    */
    #define real half
    #define real2 half2
    #define real3 half3
    #define real4 half4
    #define real2x2 half2x2
    #define real2x3 half2x3
    #define real2x4 half2x4
    #define real3x2 half3x2
    #define real3x3 half3x3
    #define real3x4 half3x4
    #define real4x3 half4x3
    #define real4x4 half4x4


    float3 SafeNormalize(float3 inVec)
    {
        float dp3 = max(FLT_MIN, dot(inVec, inVec));
        return inVec * rsqrt(dp3);
    }


    #if defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)

        #define SLICE_ARRAY_INDEX   unity_StereoEyeIndex

        #define TEXTURE2D_X(textureName)                                        TEXTURE2D_ARRAY(textureName)
        #define TEXTURE2D_X_PARAM(textureName, samplerName)                     TEXTURE2D_ARRAY_PARAM(textureName, samplerName)
        #define TEXTURE2D_X_ARGS(textureName, samplerName)                      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)
        #define TEXTURE2D_X_HALF(textureName)                                   TEXTURE2D_ARRAY_HALF(textureName)
        #define TEXTURE2D_X_FLOAT(textureName)                                  TEXTURE2D_ARRAY_FLOAT(textureName)

        #define LOAD_TEXTURE2D_X(textureName, unCoord2)                         LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, SLICE_ARRAY_INDEX)
        #define LOAD_TEXTURE2D_X_LOD(textureName, unCoord2, lod)                LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, SLICE_ARRAY_INDEX, lod)
        #define SAMPLE_TEXTURE2D_X(textureName, samplerName, coord2)            SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, SLICE_ARRAY_INDEX)
        #define SAMPLE_TEXTURE2D_X_LOD(textureName, samplerName, coord2, lod)   SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, SLICE_ARRAY_INDEX, lod)
        #define GATHER_TEXTURE2D_X(textureName, samplerName, coord2)            GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, SLICE_ARRAY_INDEX)
        #define GATHER_RED_TEXTURE2D_X(textureName, samplerName, coord2)        GATHER_RED_TEXTURE2D(textureName, samplerName, float3(coord2, SLICE_ARRAY_INDEX))
        #define GATHER_GREEN_TEXTURE2D_X(textureName, samplerName, coord2)      GATHER_GREEN_TEXTURE2D(textureName, samplerName, float3(coord2, SLICE_ARRAY_INDEX))
        #define GATHER_BLUE_TEXTURE2D_X(textureName, samplerName, coord2)       GATHER_BLUE_TEXTURE2D(textureName, samplerName, float3(coord2, SLICE_ARRAY_INDEX))

    #else
        #define SLICE_ARRAY_INDEX       0

        #define TEXTURE2D_X(textureName)                                        TEXTURE2D(textureName)
        #define TEXTURE2D_X_PARAM(textureName, samplerName)                     TEXTURE2D_PARAM(textureName, samplerName)
        #define TEXTURE2D_X_ARGS(textureName, samplerName)                      TEXTURE2D_ARGS(textureName, samplerName)
        #define TEXTURE2D_X_HALF(textureName)                                   TEXTURE2D_HALF(textureName)
        #define TEXTURE2D_X_FLOAT(textureName)                                  TEXTURE2D_FLOAT(textureName)

        #define LOAD_TEXTURE2D_X(textureName, unCoord2)                         LOAD_TEXTURE2D(textureName, unCoord2)
        #define LOAD_TEXTURE2D_X_LOD(textureName, unCoord2, lod)                LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)
        #define SAMPLE_TEXTURE2D_X(textureName, samplerName, coord2)            SAMPLE_TEXTURE2D(textureName, samplerName, coord2)
        #define SAMPLE_TEXTURE2D_X_LOD(textureName, samplerName, coord2, lod)   SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)
        #define GATHER_TEXTURE2D_X(textureName, samplerName, coord2)            GATHER_TEXTURE2D(textureName, samplerName, coord2)
        #define GATHER_RED_TEXTURE2D_X(textureName, samplerName, coord2)        GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)
        #define GATHER_GREEN_TEXTURE2D_X(textureName, samplerName, coord2)      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)
        #define GATHER_BLUE_TEXTURE2D_X(textureName, samplerName, coord2)       GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)
    #endif



    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    // SpaceTransforms.hlsl ----------------------------------------------------------------
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------


    float4x4 GetObjectToWorldMatrix()
    {
        return UNITY_MATRIX_M;
    }

    #define UNITY_MATRIX_I_M unity_WorldToObject
    float4x4 GetWorldToObjectMatrix()
    {
        return UNITY_MATRIX_I_M;
    }
    /* Does not exist in BiRP
    float4x4 GetPrevObjectToWorldMatrix()
    {
        return UNITY_PREV_MATRIX_M;
    }

    float4x4 GetPrevWorldToObjectMatrix()
    {
        return UNITY_PREV_MATRIX_I_M;
    }
    */

    float4x4 GetWorldToViewMatrix()
    {
        return UNITY_MATRIX_V;
    }

    float4x4 GetViewToWorldMatrix()
    {
        return UNITY_MATRIX_I_V;
    }

    // Transform to homogenous clip space
    float4x4 GetWorldToHClipMatrix()
    {
        return UNITY_MATRIX_VP;
    }

    // Transform to homogenous clip space
    float4x4 GetViewToHClipMatrix()
    {
        return UNITY_MATRIX_P;
    }

    // This function always return the absolute position in WS
    float3 GetAbsolutePositionWS(float3 positionRWS)
    {
    #if (SHADEROPTIONS_CAMERA_RELATIVE_RENDERING != 0)
        positionRWS += _WorldSpaceCameraPos.xyz;
    #endif
        return positionRWS;
    }

    // This function return the camera relative position in WS
    float3 GetCameraRelativePositionWS(float3 positionWS)
    {
    #if (SHADEROPTIONS_CAMERA_RELATIVE_RENDERING != 0)
        positionWS -= _WorldSpaceCameraPos.xyz;
    #endif
        return positionWS;
    }

    half GetOddNegativeScale()
    {
        // FIXME: We should be able to just return unity_WorldTransformParams.w, but it is not
        // properly set at the moment, when doing ray-tracing; once this has been fixed in cpp,
        // we can revert back to the former implementation.
        return unity_WorldTransformParams.w >= 0.0 ? 1.0 : -1.0;
    }

    float3 TransformObjectToWorld(float3 positionOS)
    {
        #if defined(SHADER_STAGE_RAY_TRACING)
        return mul(ObjectToWorld3x4(), float4(positionOS, 1.0)).xyz;
        #else
        return mul(GetObjectToWorldMatrix(), float4(positionOS, 1.0)).xyz;
        #endif
    }

    float3 TransformWorldToObject(float3 positionWS)
    {
        #if defined(SHADER_STAGE_RAY_TRACING)
        return mul(WorldToObject3x4(), float4(positionWS, 1.0)).xyz;
        #else
        return mul(GetWorldToObjectMatrix(), float4(positionWS, 1.0)).xyz;
        #endif
    }

    float3 TransformWorldToView(float3 positionWS)
    {
        return mul(GetWorldToViewMatrix(), float4(positionWS, 1.0)).xyz;
    }

    float3 TransformViewToWorld(float3 positionVS)
    {
        return mul(GetViewToWorldMatrix(), float4(positionVS, 1.0)).xyz;
    }

    // Transforms position from object space to homogenous space
    float4 TransformObjectToHClip(float3 positionOS)
    {
        // More efficient than computing M*VP matrix product
        return mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), float4(positionOS, 1.0)));
    }

    // Transforms position from world space to homogenous space
    float4 TransformWorldToHClip(float3 positionWS)
    {
        return mul(GetWorldToHClipMatrix(), float4(positionWS, 1.0));
    }

    // Transforms position from view space to homogenous space
    float4 TransformWViewToHClip(float3 positionVS)
    {
        return mul(GetViewToHClipMatrix(), float4(positionVS, 1.0));
    }

    // Normalize to support uniform scaling
    float3 TransformObjectToWorldDir(float3 dirOS, bool doNormalize = true)
    {
        #ifndef SHADER_STAGE_RAY_TRACING
        float3 dirWS = mul((float3x3)GetObjectToWorldMatrix(), dirOS);
        #else
        float3 dirWS = mul((float3x3)ObjectToWorld3x4(), dirOS);
        #endif
        if (doNormalize)
            return SafeNormalize(dirWS);
        return dirWS;
    }

    // Normalize to support uniform scaling
    float3 TransformWorldToObjectDir(float3 dirWS, bool doNormalize = true)
    {
        #ifndef SHADER_STAGE_RAY_TRACING
        float3 dirOS = mul((float3x3)GetWorldToObjectMatrix(), dirWS);
        #else
        float3 dirOS = mul((float3x3)WorldToObject3x4(), dirWS);
        #endif
        if (doNormalize)
            return normalize(dirOS);

        return dirOS;
    }

    // Transforms vector from world space to view space
    float3 TransformWorldToViewDir(float3 dirWS, bool doNormalize = false)
    {
        float3 dirVS = mul( (float3x3)UNITY_MATRIX_V, dirWS).xyz;
        if (doNormalize)
            return normalize(dirVS);

        return dirVS;
    }

    // Transforms vector from view space to world space
    float3 TransformViewToWorldDir(float3 dirVS, bool doNormalize = false)
    {
        float3 dirWS = mul((float3x3)GetViewToWorldMatrix(), dirVS).xyz;
        if (doNormalize)
            return normalize(dirWS);

        return dirWS;
    }

    // Transforms normal from world space to view space
    float3 TransformWorldToViewNormal(float3 normalWS, bool doNormalize = false)
    {
        // assuming view matrix is uniformly scaled, we can use direction transform
        return TransformWorldToViewDir(normalWS, doNormalize);
    }

    // Transforms normal from view space to world space
    float3 TransformViewToWorldNormal(float3 normalVS, bool doNormalize = false)
    {
        // assuming view matrix is uniformly scaled, we can use direction transform
        return TransformViewToWorldDir(normalVS, doNormalize);
    }

    // Transforms vector from world space to homogenous space
    float3 TransformWorldToHClipDir(float3 directionWS, bool doNormalize = false)
    {
        float3 dirHCS = mul((float3x3)GetWorldToHClipMatrix(), directionWS).xyz;
        if (doNormalize)
            return normalize(dirHCS);

        return dirHCS;
    }

    // Transforms normal from object to world space
    float3 TransformObjectToWorldNormal(float3 normalOS, bool doNormalize = true)
    {
    #ifdef UNITY_ASSUME_UNIFORM_SCALING
        return TransformObjectToWorldDir(normalOS, doNormalize);
    #else
        // Normal need to be multiply by inverse transpose
        float3 normalWS = mul(normalOS, (float3x3)GetWorldToObjectMatrix());
        if (doNormalize)
            return SafeNormalize(normalWS);

        return normalWS;
    #endif
    }

    // Transforms normal from world to object space
    float3 TransformWorldToObjectNormal(float3 normalWS, bool doNormalize = true)
    {
    #ifdef UNITY_ASSUME_UNIFORM_SCALING
        return TransformWorldToObjectDir(normalWS, doNormalize);
    #else
        // Normal need to be multiply by inverse transpose
        float3 normalOS = mul(normalWS, (float3x3)GetObjectToWorldMatrix());
        if (doNormalize)
            return SafeNormalize(normalOS);

        return normalOS;
    #endif
    }

    float3x3 CreateTangentToWorld(float3 normal, float3 tangent, float flipSign)
    {
        // For odd-negative scale transforms we need to flip the sign
        float sgn = flipSign * GetOddNegativeScale();
        float3 bitangent = cross(normal, tangent) * sgn;

        return float3x3(tangent, bitangent, normal);
    }

    // this function is intended to work on Normals (handles non-uniform scale)
    // tangentToWorld is the matrix representing the transformation of a normal from tangent to world space
    float3 TransformTangentToWorld(float3 normalTS, float3x3 tangentToWorld, bool doNormalize = false)
    {
        // Note matrix is in row major convention with left multiplication as it is build on the fly
        float3 result = mul(normalTS, tangentToWorld);
        if (doNormalize)
            return SafeNormalize(result);
        return result;
    }

    // this function is intended to work on Normals (handles non-uniform scale)
    // This function does the exact inverse of TransformTangentToWorld() and is
    // also decribed within comments in mikktspace.h and it follows implicitly
    // from the scalar triple product (google it).
    // tangentToWorld is the matrix representing the transformation of a normal from tangent to world space
    float3 TransformWorldToTangent(float3 normalWS, float3x3 tangentToWorld, bool doNormalize = true)
    {
        // Note matrix is in row major convention with left multiplication as it is build on the fly
        float3 row0 = tangentToWorld[0];
        float3 row1 = tangentToWorld[1];
        float3 row2 = tangentToWorld[2];

        // these are the columns of the inverse matrix but scaled by the determinant
        float3 col0 = cross(row1, row2);
        float3 col1 = cross(row2, row0);
        float3 col2 = cross(row0, row1);

        float determinant = dot(row0, col0);

        // inverse transposed but scaled by determinant
        // Will remove transpose part by using matrix as the first arg in the mul() below
        // this makes it the exact inverse of what TransformTangentToWorld() does.
        float3x3 matTBN_I_T = float3x3(col0, col1, col2);
        float3 result = mul(matTBN_I_T, normalWS);
        if (doNormalize)
        {
            float sgn = determinant < 0.0 ? (-1.0) : 1.0;
            return SafeNormalize(sgn * result);
        }
        else
            return result / determinant;
    }

    // this function is intended to work on Vectors/Directions
    // tangentToWorld is the matrix representing the transformation of a normal from tangent to world space
    float3 TransformWorldToTangentDir(float3 dirWS, float3x3 tangentToWorld, bool doNormalize = false)
    {
        // Note matrix is in row major convention with left multiplication as it is build on the fly
        float3 result = mul(tangentToWorld, dirWS);
        if (doNormalize)
            return SafeNormalize(result);
        return result;
    }

    // this function is intended to work on Vectors/Directions
    // This function does the exact inverse of TransformWorldToTangentDir()
    // tangentToWorld is the matrix representing the transformation of a normal from tangent to world space
    float3 TransformTangentToWorldDir(float3 dirWS, float3x3 tangentToWorld, bool doNormalize = false)
    {
        // Note matrix is in row major convention with left multiplication as it is build on the fly
        float3 row0 = tangentToWorld[0];
        float3 row1 = tangentToWorld[1];
        float3 row2 = tangentToWorld[2];

        // these are the columns of the inverse matrix but scaled by the determinant
        float3 col0 = cross(row1, row2);
        float3 col1 = cross(row2, row0);
        float3 col2 = cross(row0, row1);

        float determinant = dot(row0, col0);

        // inverse transposed but scaled by determinant
        // Will remove transpose part by using matrix as the second arg in the mul() below
        // this makes it the exact inverse of what TransformWorldToTangentDir() does.
        float3x3 matTBN_I_T = float3x3(col0, col1, col2);
        float3 result = mul(dirWS, matTBN_I_T);
        if (doNormalize)
        {
            float sgn = determinant < 0.0 ? (-1.0) : 1.0;
            return SafeNormalize(sgn * result);
        }
        else
            return result / determinant;
    }

    // tangentToWorld is the matrix representing the transformation of a normal from tangent to world space
    float3 TransformTangentToObject(float3 dirTS, float3x3 tangentToWorld)
    {
        // Note matrix is in row major convention with left multiplication as it is build on the fly
        float3 normalWS = TransformTangentToWorld(dirTS, tangentToWorld);
        return TransformWorldToObjectNormal(normalWS);
    }

    // tangentToWorld is the matrix representing the transformation of a normal from tangent to world space
    float3 TransformObjectToTangent(float3 dirOS, float3x3 tangentToWorld)
    {
        // Note matrix is in row major convention with left multiplication as it is build on the fly

        // don't normalize, as normalWS will be normalized after TransformWorldToTangent
        float3 normalWS = TransformObjectToWorldNormal(dirOS, false);

        // transform from world to tangent
        return TransformWorldToTangent(normalWS, tangentToWorld);
    }

    // orels1 additions

    float3 GetObjectScale()
    {
        float4x4 objToWorld = GetObjectToWorldMatrix();
        return float3(
            length(objToWorld._m00_m10_m20),
            length(objToWorld._m01_m11_m21),
            length(objToWorld._m02_m12_m22)
        );
    }

    float4 GetScreenPosition(float4 positionCS)
    {
        float4 ndc = positionCS * 0.5f;
        ndc.xy = float2(ndc.x, ndc.y * _ProjectionParams.x) + ndc.w;
        ndc.zw = positionCS.zw;

        ndc.xy = TransformStereoScreenSpaceTex(ndc.xy, ndc.w);
        return ndc;
    }

    // Delcare things in-place so that the sampler/texture can be used in the function below
    TEXTURE2D_X_FLOAT(_CameraDepthTexture);
    SAMPLER(sampler_CameraDepthTexture);

    float SampleSceneDepth(float2 uv)
    {
        return SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, uv).r;
    }

    // We need this so that we can replace `UNITY_LIGHT_ATTENUATION`
    struct Light
    {
        float3   direction;
        half3   color;
        half    shadowAttenuation;
    };

    Light GetMainLight()
    {
        Light light;
        
        light.direction = _WorldSpaceLightPos0.xyz;
        light.shadowAttenuation = 1.0;
        light.color = _LightColor0.rgb;

        return light;
    }

    struct __BridgeShadowStruct
    {
        float4 pos;
        float4 _ShadowCoord;
    };

    Light GetMainLight(float4 shadowCoord)
    {
        Light light = GetMainLight();

        __BridgeShadowStruct input = (__BridgeShadowStruct) 0;
        input._ShadowCoord = shadowCoord;
        UNITY_LIGHT_ATTENUATION(lightAttenuation, input, 0..xxx);
        light.shadowAttenuation = lightAttenuation;
        return light;
    }

    Light GetMainLight(float4 shadowCoord, float3 positionWS, half4 shadowMask)
    {
        Light light = GetMainLight();

        // In BIRP we consider all lights "main lights", so we utilize world space position to get final light direction
        #ifndef USING_DIRECTIONAL_LIGHT
        light.direction = normalize(UnityWorldSpaceLightDir(positionWS));
        #endif
        
        __BridgeShadowStruct input = (__BridgeShadowStruct) 0;
        input._ShadowCoord = shadowCoord;
        UNITY_LIGHT_ATTENUATION(lightAttenuation, input, positionWS);
        
        light.shadowAttenuation = lightAttenuation;

        return light;
    }

    float3 UnpackNormalScale(float4 packedNormal, float scale)
    {
        return UnpackScaleNormal(packedNormal, scale);
    }

    void LODFadeCrossFade(float2 positionCS)
    {
        #if defined(LOD_FADE_CROSSFADE)
        UnityApplyDitherCrossFade(positionCS.xy);
        #endif
    }
    #endif
}