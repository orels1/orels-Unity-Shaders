%Properties()
{
    UI_ParallaxHeader("# Parallax", Int) = 0
    UI_ParallaxDocs("[This module has documentation](https://shaders.orels.sh/docs/orl-standard/base-shader#parallax)", Int) = 0
    [Toggle(PARALLAX)]_EnableParallax("Enable Parallax", Int) = 0
    [NoScaleOffset]_Height("Height > %ShowIf(PARALLAX)", 2D) = "black" {}
    _HeightScale("Height Scale %ShowIf(PARALLAX)", Range(0, 0.1)) = 0.006
    _HeightRefPlane("Height Ref Plane %ShowIf(PARALLAX)", Range(-1, 1)) = 0.5
    _HeightStepsMin("Steps Min %ShowIf(PARALLAX)", Range(8, 32)) = 8
    _HeightStepsMax("Steps Max %ShowIf(PARALLAX)", Range(8, 32)) = 16
}

%ShaderFeatures()
{
    #pragma shader_feature_local_fragment PARALLAX
}

%Variables()
{
    half _HeightScale;
    half _HeightRefPlane;
    half _HeightStepsMin;
    half _HeightStepsMax;
    
    float2 GLOBAL_parallaxUv;

    half GLOBAL_heightMask;
    half GLOBAL_heightMaskSmoothing;
    
    int GLOBAL_heightSet;
    half GLOBAL_height; 
}

%Textures()
{
    TEXTURE2D(_Height);
    SAMPLER(sampler_Height);
}

%Fragment("ParallaxFragment", -100)
{
    // mostly taken from the Amplify shader reference
    float2 POM(Texture2D heightMap, SamplerState heightSampler, float2 uvs, float2 dx, float2 dy, float3 normalWorld, float3 viewWorld, float3 viewDirTan, int minSamples, int maxSamples, float parallax, float refPlane, float2 tilling, float2 curv, int index, float heightMask, float heightMaskSmoothing, inout float finalHeight)
    {
        int stepIndex = 0;
        int numSteps = (int)lerp((float)maxSamples, (float)minSamples, saturate(dot(normalWorld, viewWorld)));
        float layerHeight = 1.0 / numSteps;
        float2 plane = parallax * (viewDirTan.xy / viewDirTan.z);
        uvs.xy += refPlane * plane;
        float2 deltaTex = -plane * layerHeight;
        float2 prevTexOffset = 0;
        float prevRayZ = 1.0f;
        float prevHeight = 0.0f;
        float2 currTexOffset = deltaTex;
        float currRayZ = 1.0f - layerHeight;
        float currHeight = 0.0f;
        float intersection = 0;
        float2 finalTexOffset = 0;
        while (stepIndex < numSteps + 1)
        {
            currHeight = SAMPLE_TEXTURE2D_GRAD(heightMap, heightSampler, uvs + currTexOffset, dx, dy).r;
            #if defined(POM_HEIGHT_MASK_SET)
            float mask = smoothstep(currHeight - heightMaskSmoothing, currHeight, heightMask);
            currHeight = lerp(currHeight, heightMask, mask);
            #endif
            if (currHeight > currRayZ)
            {
                stepIndex = numSteps + 1;
            }
            else
            {
                stepIndex++;
                prevTexOffset = currTexOffset;
                prevRayZ = currRayZ;
                prevHeight = currHeight;
                currTexOffset += deltaTex;
                currRayZ -= layerHeight;
            }
        }
        int sectionSteps = 2;
        int sectionIndex = 0;
        float newZ = 0;
        float newHeight = 0;
        while (sectionIndex < sectionSteps)
        {
            intersection = (prevHeight - prevRayZ) / (prevHeight - currHeight + currRayZ - prevRayZ);
            finalTexOffset = prevTexOffset +intersection * deltaTex;
            newZ = prevRayZ - intersection * layerHeight;
            newHeight = SAMPLE_TEXTURE2D_GRAD(heightMap, heightSampler, uvs + finalTexOffset, dx, dy).r;
            #if defined(POM_HEIGHT_MASK_SET)
            float mask = smoothstep(newHeight - heightMaskSmoothing, newHeight, heightMask);
            newHeight = lerp(newHeight, heightMask, mask);
            #endif
            if (newHeight > newZ)
            {
                currTexOffset = finalTexOffset;
                currHeight = newHeight;
                currRayZ = newZ;
                deltaTex = intersection * deltaTex;
                layerHeight = intersection * layerHeight;
            }
            else
            {
                prevTexOffset = finalTexOffset;
                prevHeight = newHeight;
                prevRayZ = newZ;
                deltaTex = (1 - intersection) * deltaTex;
                layerHeight = (1 - intersection) * layerHeight;
            }
            sectionIndex++;
        }
        finalHeight = newHeight;
        return uvs.xy + finalTexOffset;
    }

    void ParallaxFragment(MeshData d)
    {
      // this is a bit "magical" but basically we just push to global UVs
      // and then any other module will read from them
      // we use FragmentQueue to push the actual function call above the other modules
      GLOBAL_parallaxUv = d.uv0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
      #if defined(PARALLAX) && !defined(PLAT_QUEST)
        float customHeight = 0;
        GLOBAL_parallaxUv = POM(_Height,
            sampler_Height,
            GLOBAL_parallaxUv,
            ddx(GLOBAL_parallaxUv),
            ddy(GLOBAL_parallaxUv),
            d.worldNormal,
            d.worldSpaceViewDir,
            d.tangentSpaceViewDir,
            _HeightStepsMin,
            _HeightStepsMax,
            _HeightScale,
            _HeightRefPlane,
            float2(1, 1),
            float2(0, 0),
            0,
            GLOBAL_heightMask,
            GLOBAL_heightMaskSmoothing,
            customHeight
        );
        GLOBAL_height = customHeight;
        GLOBAL_heightSet = 1;
      #endif
    }
}