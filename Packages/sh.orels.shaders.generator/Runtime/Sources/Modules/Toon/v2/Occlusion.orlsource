%Properties()
{
    UI_OcclusionHeader("# Occlusion", Int) = 1
    _OcclusionMap("Occlusion >", 2D) = "white" {}
    _OcclusionStrength("Occlusion Strength %ShowIf(_OcclusionMap)", Range(0,1)) = 0
    [Enum(Synced With Albedo, 0, Independent, 1)]_OcclusionTilingMode("Tiling Mode %ShowIf(_OcclusionMap)", Int) = 0
    _OcclusionTiling("Tiling %ShowIf(_OcclusionMap)", Float) = 1
    UI_OcclusionTilingSyncedNote("> Will scale UVs based on the Albedo texture Tiling and Offset settings %ShowIf(_OcclusionTilingMode == 0 && _OcclusionMap)", Int) = 0
    UI_OcclusionTilingIndependentNote("> Will scale UVs on its own %ShowIf(_OcclusionTilingMode == 1 && _OcclusionMap)", Int) = 0

    [ToggleUI]_OcclusionDetailEnabled("Occlusion Detail Enabled", Int) = 0
    _OcclusionDetail("Occlusion Detail > %ShowIf(_OcclusionDetailEnabled)", 2D) = "white" {}
    _OcclusionDetailStrength("Occlusion Detail Strength %ShowIf(_OcclusionDetail && _OcclusionDetailEnabled)", Range(0,1)) = 1
    [Enum(Synced With Albedo, 0, Independent, 1)]_OcclusionDetailTilingMode("Tiling Mode %ShowIf(_OcclusionDetail)", Int) = 0
    _OcclusionDetailTiling("Tiling %ShowIf(_OcclusionDetail)", Float) = 1
    UI_OcclusionDetailTilingSyncedNote("> Will scale UVs based on the Albedo texture Tiling and Offset settings %ShowIf(_OcclusionDetailTilingMode == 0 && _OcclusionDetail)", Int) = 0
    UI_OcclusionDetailTilingIndependentNote("> Will scale UVs on its own %ShowIf(_OcclusionDetailTilingMode == 1 && _OcclusionDetail)", Int) = 0

    // [Toggle(SSAO)]_SSAOEnabled("Screen Space Occlusion", Int) = 0
    // _SSAONoiseTexture("Noise Texture > %RequiredTexture(@/SSRNoise.png) %ShowIf(SSAO)", 2D) = "black" {}
    // _SSAORadius("Radius %ShowIf(SSAO)", Float) = 5
    // _SSAOPower("Power %ShowIf(SSAO)", Float) = 3
    // _SSAOBoost("Boost %ShowIf(SSAO)", Float) = 1
    // _SSAOStrength("Strength %ShowIf(SSAO)", Range(0,1)) = 1
}

%ShaderFeatures()
{
    // #pragma shader_feature_local_fragment SSAO
}

%Variables()
{
    half _OcclusionStrength;
    int _OcclusionTilingMode;
    half _OcclusionTiling;

    int _OcclusionDetailEnabled;
    half _OcclusionDetailStrength;
    int _OcclusionDetailTilingMode;
    half _OcclusionDetailTiling;

    float4 _SSAONoiseTexture_TexelSize;
    half _SSAORadius;
    half _SSAOPower;
    half _SSAOBoost;
    half _SSAOStrength;
}

%Textures()
{
    TEXTURE2D(_OcclusionMap);
    TEXTURE2D(_OcclusionDetail);

    #if defined(SSAO)
    TEXTURE2D(_SSAONoiseTexture);
    SAMPLER(sampler_SSAONoiseTexture);
    #endif
}

%Fragment("ToonOcclusionFragment")
{
    float chash11(float p)
    {
        p = frac(p * .1031);
        p *= p + 33.33;
        p *= p + p;
        return frac(p);
    }

    float3 chash31(float p)
    {
        float3 p3 = frac(p * float3(.1031, .1030, .0973));
        p3 += dot(p3, p3.yzx+33.33);
        return frac((p3.xxy+p3.yzz)*p3.zyx); 
    }

    void ToonOcclusionFragment(MeshData d, inout SurfaceData o) {
        half2 globalUv = 0;

        #if defined(GLOBAL_UV_SET)
        globalUv = GLOBAL_uv;
        #else
        globalUv = d.uv0;
        #endif

        half occlusion = SAMPLE_TEXTURE2D(_OcclusionMap, sampler_MainTex, lerp(globalUv * _OcclusionTiling, d.uv0 * _OcclusionTiling, _OcclusionTilingMode)).r;
        o.Occlusion = lerp(1, occlusion, _OcclusionStrength);
        
        if (_OcclusionDetailEnabled) {
            half occlusionDetail = SAMPLE_TEXTURE2D(_OcclusionDetail, sampler_MainTex, lerp(globalUv * _OcclusionDetailTiling, d.uv0 * _OcclusionDetailTiling, _OcclusionDetailTilingMode)).r;
            o.Occlusion *= lerp(1, occlusionDetail, _OcclusionDetailStrength);
        }

        #if defined(SSAO)
        // float3 startingPoint = d.worldSpacePosition.xyz;
        // float3 worldNormal = Unity_SafeNormalize(mul(o.Normal, d.TBNMatrix));
        // // float3 dir = worldNormal;

        // float radius = _SSAORadius / 100.0;
        // float3 samplePoint = 0;

        // half ssao = 0;

        // const int kernelSize = 16;

        // float3 ssaoKernel[kernelSize];
        // float4 noiseUvs = d.screenPos;
        // noiseUvs.xy = (noiseUvs.xy * _ScreenParams.xy) / (_SSAONoiseTexture_TexelSize.zw * noiseUvs.w);	

        // float3 noise = SAMPLE_TEXTURE2D_LOD(_SSAONoiseTexture, sampler_SSAONoiseTexture, noiseUvs.xy,0).xyz;
        // noise.x = noise.x * 2 - 1;
        // noise.y = noise.y * 2 - 1;

        // // kernel
        // [loop]
        // for (int i = 0; i < kernelSize; i++)
        // {
        //     // ssaoKernel[i] = chash31(chash11(i));
        //     // ssaoKernel[i].x = ssaoKernel[i].x * 2 - 1;
        //     // ssaoKernel[i].y = ssaoKernel[i].y * 2 - 1;
        //     ssaoKernel[i] = noise.xyz;
        //     float scale = (float) i / (float) kernelSize;
        //     float scaleMultiplier = lerp(0.1,1.0, scale * scale);
        //     ssaoKernel[i] *= scaleMultiplier;
        //     ssaoKernel[i] = mul(ssaoKernel[i], d.TBNMatrix);
        // }
        // // float3 randomDir = float3(noise.xy, 0);
        // // float3 randomTangent = normalize(randomDir - dot(randomDir, worldNormal) * worldNormal);
        // // float3 randomBitangent = cross(worldNormal, randomTangent);
        // // float3x3 TBN = float3x3(randomTangent, randomBitangent, worldNormal);

        // // startingPoint += worldNormal * 0.01;

        // [loop]
        // for (int j = 0; j < kernelSize; j++) {
        //     // samplePoint = startingPoint + mul(ssaoKernel[j], TBN) * radius;
        //     samplePoint = startingPoint + ssaoKernel[j] * radius;
        //     // float samplePointZ = LinearEyeDepth(SampleSceneDepth(d.screenPos.xy / d.screenPos.w));
        //     float samplePointZ = d.screenPos.z;
        //     float3 sampleDir = normalize(samplePoint - startingPoint);
        //     float NoS = saturate(dot(worldNormal, sampleDir));
        //     float4 offset = GetScreenPosition(TransformWorldToHClip(samplePoint));
        //     offset.xy /= offset.w;
        //     float sceneDepth = LinearEyeDepth(SampleSceneDepth(offset.xy));
        //     float rangeCheck = saturate(radius / abs(samplePointZ - sceneDepth));
        //     ssao += rangeCheck * step(sceneDepth + 0.005, samplePointZ) * NoS;
        // }
        // ssao = (ssao / (float) kernelSize);
        // ssao = pow(saturate(1 - saturate(ssao * _SSAOBoost)), _SSAOPower);
        // o.Occlusion *= lerp(1, ssao, _SSAOStrength);
        #endif
    }
}